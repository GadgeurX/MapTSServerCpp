// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_SCHEMA_PACKET_H_
#define FLATBUFFERS_GENERATED_SCHEMA_PACKET_H_

#include "flatbuffers/flatbuffers.h"

namespace packet {

struct EntityId;
struct EntityIdBuilder;

struct RegisterPacket;
struct RegisterPacketBuilder;

struct SelectFirstTerritory;
struct SelectFirstTerritoryBuilder;

struct RequestAllTerritoryBoundaryPacket;
struct RequestAllTerritoryBoundaryPacketBuilder;

struct TerritoryBoundary;
struct TerritoryBoundaryBuilder;

struct AllTerritoryBoundaryPacket;
struct AllTerritoryBoundaryPacketBuilder;

struct ActionPacket;
struct ActionPacketBuilder;

struct OkPacket;
struct OkPacketBuilder;

struct ErrorPacket;
struct ErrorPacketBuilder;

struct LoginPacket;
struct LoginPacketBuilder;

struct Position;
struct PositionBuilder;

struct Packet;
struct PacketBuilder;

enum ActionType {
  ActionType_DEFAULT = 0,
  ActionType_MOVE = 1,
  ActionType_ATTACK = 2,
  ActionType_MIN = ActionType_DEFAULT,
  ActionType_MAX = ActionType_ATTACK
};

inline const ActionType (&EnumValuesActionType())[3] {
  static const ActionType values[] = {
    ActionType_DEFAULT,
    ActionType_MOVE,
    ActionType_ATTACK
  };
  return values;
}

inline const char * const *EnumNamesActionType() {
  static const char * const names[4] = {
    "DEFAULT",
    "MOVE",
    "ATTACK",
    nullptr
  };
  return names;
}

inline const char *EnumNameActionType(ActionType e) {
  if (flatbuffers::IsOutRange(e, ActionType_DEFAULT, ActionType_ATTACK)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesActionType()[index];
}

enum Target {
  Target_NONE = 0,
  Target_EntityId = 1,
  Target_Position = 2,
  Target_MIN = Target_NONE,
  Target_MAX = Target_Position
};

inline const Target (&EnumValuesTarget())[3] {
  static const Target values[] = {
    Target_NONE,
    Target_EntityId,
    Target_Position
  };
  return values;
}

inline const char * const *EnumNamesTarget() {
  static const char * const names[4] = {
    "NONE",
    "EntityId",
    "Position",
    nullptr
  };
  return names;
}

inline const char *EnumNameTarget(Target e) {
  if (flatbuffers::IsOutRange(e, Target_NONE, Target_Position)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTarget()[index];
}

template<typename T> struct TargetTraits {
  static const Target enum_value = Target_NONE;
};

template<> struct TargetTraits<packet::EntityId> {
  static const Target enum_value = Target_EntityId;
};

template<> struct TargetTraits<packet::Position> {
  static const Target enum_value = Target_Position;
};

bool VerifyTarget(flatbuffers::Verifier &verifier, const void *obj, Target type);
bool VerifyTargetVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum PacketType {
  PacketType_NONE = 0,
  PacketType_LoginPacket = 1,
  PacketType_ActionPacket = 2,
  PacketType_OkPacket = 3,
  PacketType_ErrorPacket = 4,
  PacketType_RegisterPacket = 5,
  PacketType_SelectFirstTerritory = 6,
  PacketType_RequestAllTerritoryBoundaryPacket = 7,
  PacketType_AllTerritoryBoundaryPacket = 8,
  PacketType_MIN = PacketType_NONE,
  PacketType_MAX = PacketType_AllTerritoryBoundaryPacket
};

inline const PacketType (&EnumValuesPacketType())[9] {
  static const PacketType values[] = {
    PacketType_NONE,
    PacketType_LoginPacket,
    PacketType_ActionPacket,
    PacketType_OkPacket,
    PacketType_ErrorPacket,
    PacketType_RegisterPacket,
    PacketType_SelectFirstTerritory,
    PacketType_RequestAllTerritoryBoundaryPacket,
    PacketType_AllTerritoryBoundaryPacket
  };
  return values;
}

inline const char * const *EnumNamesPacketType() {
  static const char * const names[10] = {
    "NONE",
    "LoginPacket",
    "ActionPacket",
    "OkPacket",
    "ErrorPacket",
    "RegisterPacket",
    "SelectFirstTerritory",
    "RequestAllTerritoryBoundaryPacket",
    "AllTerritoryBoundaryPacket",
    nullptr
  };
  return names;
}

inline const char *EnumNamePacketType(PacketType e) {
  if (flatbuffers::IsOutRange(e, PacketType_NONE, PacketType_AllTerritoryBoundaryPacket)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPacketType()[index];
}

template<typename T> struct PacketTypeTraits {
  static const PacketType enum_value = PacketType_NONE;
};

template<> struct PacketTypeTraits<packet::LoginPacket> {
  static const PacketType enum_value = PacketType_LoginPacket;
};

template<> struct PacketTypeTraits<packet::ActionPacket> {
  static const PacketType enum_value = PacketType_ActionPacket;
};

template<> struct PacketTypeTraits<packet::OkPacket> {
  static const PacketType enum_value = PacketType_OkPacket;
};

template<> struct PacketTypeTraits<packet::ErrorPacket> {
  static const PacketType enum_value = PacketType_ErrorPacket;
};

template<> struct PacketTypeTraits<packet::RegisterPacket> {
  static const PacketType enum_value = PacketType_RegisterPacket;
};

template<> struct PacketTypeTraits<packet::SelectFirstTerritory> {
  static const PacketType enum_value = PacketType_SelectFirstTerritory;
};

template<> struct PacketTypeTraits<packet::RequestAllTerritoryBoundaryPacket> {
  static const PacketType enum_value = PacketType_RequestAllTerritoryBoundaryPacket;
};

template<> struct PacketTypeTraits<packet::AllTerritoryBoundaryPacket> {
  static const PacketType enum_value = PacketType_AllTerritoryBoundaryPacket;
};

bool VerifyPacketType(flatbuffers::Verifier &verifier, const void *obj, PacketType type);
bool VerifyPacketTypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct EntityId FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef EntityIdBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4
  };
  uint32_t id() const {
    return GetField<uint32_t>(VT_ID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_ID) &&
           verifier.EndTable();
  }
};

struct EntityIdBuilder {
  typedef EntityId Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(uint32_t id) {
    fbb_.AddElement<uint32_t>(EntityId::VT_ID, id, 0);
  }
  explicit EntityIdBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EntityIdBuilder &operator=(const EntityIdBuilder &);
  flatbuffers::Offset<EntityId> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EntityId>(end);
    return o;
  }
};

inline flatbuffers::Offset<EntityId> CreateEntityId(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id = 0) {
  EntityIdBuilder builder_(_fbb);
  builder_.add_id(id);
  return builder_.Finish();
}

struct RegisterPacket FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RegisterPacketBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LOGIN = 4,
    VT_EMAIL = 6,
    VT_PASSWORD = 8
  };
  const flatbuffers::String *login() const {
    return GetPointer<const flatbuffers::String *>(VT_LOGIN);
  }
  const flatbuffers::String *email() const {
    return GetPointer<const flatbuffers::String *>(VT_EMAIL);
  }
  const flatbuffers::String *password() const {
    return GetPointer<const flatbuffers::String *>(VT_PASSWORD);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_LOGIN) &&
           verifier.VerifyString(login()) &&
           VerifyOffset(verifier, VT_EMAIL) &&
           verifier.VerifyString(email()) &&
           VerifyOffset(verifier, VT_PASSWORD) &&
           verifier.VerifyString(password()) &&
           verifier.EndTable();
  }
};

struct RegisterPacketBuilder {
  typedef RegisterPacket Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_login(flatbuffers::Offset<flatbuffers::String> login) {
    fbb_.AddOffset(RegisterPacket::VT_LOGIN, login);
  }
  void add_email(flatbuffers::Offset<flatbuffers::String> email) {
    fbb_.AddOffset(RegisterPacket::VT_EMAIL, email);
  }
  void add_password(flatbuffers::Offset<flatbuffers::String> password) {
    fbb_.AddOffset(RegisterPacket::VT_PASSWORD, password);
  }
  explicit RegisterPacketBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RegisterPacketBuilder &operator=(const RegisterPacketBuilder &);
  flatbuffers::Offset<RegisterPacket> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RegisterPacket>(end);
    return o;
  }
};

inline flatbuffers::Offset<RegisterPacket> CreateRegisterPacket(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> login = 0,
    flatbuffers::Offset<flatbuffers::String> email = 0,
    flatbuffers::Offset<flatbuffers::String> password = 0) {
  RegisterPacketBuilder builder_(_fbb);
  builder_.add_password(password);
  builder_.add_email(email);
  builder_.add_login(login);
  return builder_.Finish();
}

inline flatbuffers::Offset<RegisterPacket> CreateRegisterPacketDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *login = nullptr,
    const char *email = nullptr,
    const char *password = nullptr) {
  auto login__ = login ? _fbb.CreateString(login) : 0;
  auto email__ = email ? _fbb.CreateString(email) : 0;
  auto password__ = password ? _fbb.CreateString(password) : 0;
  return packet::CreateRegisterPacket(
      _fbb,
      login__,
      email__,
      password__);
}

struct SelectFirstTerritory FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SelectFirstTerritoryBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4
  };
  uint32_t id() const {
    return GetField<uint32_t>(VT_ID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_ID) &&
           verifier.EndTable();
  }
};

struct SelectFirstTerritoryBuilder {
  typedef SelectFirstTerritory Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(uint32_t id) {
    fbb_.AddElement<uint32_t>(SelectFirstTerritory::VT_ID, id, 0);
  }
  explicit SelectFirstTerritoryBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SelectFirstTerritoryBuilder &operator=(const SelectFirstTerritoryBuilder &);
  flatbuffers::Offset<SelectFirstTerritory> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SelectFirstTerritory>(end);
    return o;
  }
};

inline flatbuffers::Offset<SelectFirstTerritory> CreateSelectFirstTerritory(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id = 0) {
  SelectFirstTerritoryBuilder builder_(_fbb);
  builder_.add_id(id);
  return builder_.Finish();
}

struct RequestAllTerritoryBoundaryPacket FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RequestAllTerritoryBoundaryPacketBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct RequestAllTerritoryBoundaryPacketBuilder {
  typedef RequestAllTerritoryBoundaryPacket Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit RequestAllTerritoryBoundaryPacketBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RequestAllTerritoryBoundaryPacketBuilder &operator=(const RequestAllTerritoryBoundaryPacketBuilder &);
  flatbuffers::Offset<RequestAllTerritoryBoundaryPacket> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RequestAllTerritoryBoundaryPacket>(end);
    return o;
  }
};

inline flatbuffers::Offset<RequestAllTerritoryBoundaryPacket> CreateRequestAllTerritoryBoundaryPacket(
    flatbuffers::FlatBufferBuilder &_fbb) {
  RequestAllTerritoryBoundaryPacketBuilder builder_(_fbb);
  return builder_.Finish();
}

struct TerritoryBoundary FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TerritoryBoundaryBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SHAPE = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<packet::Position>> *shape() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<packet::Position>> *>(VT_SHAPE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SHAPE) &&
           verifier.VerifyVector(shape()) &&
           verifier.VerifyVectorOfTables(shape()) &&
           verifier.EndTable();
  }
};

struct TerritoryBoundaryBuilder {
  typedef TerritoryBoundary Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_shape(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<packet::Position>>> shape) {
    fbb_.AddOffset(TerritoryBoundary::VT_SHAPE, shape);
  }
  explicit TerritoryBoundaryBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TerritoryBoundaryBuilder &operator=(const TerritoryBoundaryBuilder &);
  flatbuffers::Offset<TerritoryBoundary> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TerritoryBoundary>(end);
    return o;
  }
};

inline flatbuffers::Offset<TerritoryBoundary> CreateTerritoryBoundary(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<packet::Position>>> shape = 0) {
  TerritoryBoundaryBuilder builder_(_fbb);
  builder_.add_shape(shape);
  return builder_.Finish();
}

inline flatbuffers::Offset<TerritoryBoundary> CreateTerritoryBoundaryDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<packet::Position>> *shape = nullptr) {
  auto shape__ = shape ? _fbb.CreateVector<flatbuffers::Offset<packet::Position>>(*shape) : 0;
  return packet::CreateTerritoryBoundary(
      _fbb,
      shape__);
}

struct AllTerritoryBoundaryPacket FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AllTerritoryBoundaryPacketBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TERRITORIES = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<packet::TerritoryBoundary>> *territories() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<packet::TerritoryBoundary>> *>(VT_TERRITORIES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TERRITORIES) &&
           verifier.VerifyVector(territories()) &&
           verifier.VerifyVectorOfTables(territories()) &&
           verifier.EndTable();
  }
};

struct AllTerritoryBoundaryPacketBuilder {
  typedef AllTerritoryBoundaryPacket Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_territories(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<packet::TerritoryBoundary>>> territories) {
    fbb_.AddOffset(AllTerritoryBoundaryPacket::VT_TERRITORIES, territories);
  }
  explicit AllTerritoryBoundaryPacketBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AllTerritoryBoundaryPacketBuilder &operator=(const AllTerritoryBoundaryPacketBuilder &);
  flatbuffers::Offset<AllTerritoryBoundaryPacket> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AllTerritoryBoundaryPacket>(end);
    return o;
  }
};

inline flatbuffers::Offset<AllTerritoryBoundaryPacket> CreateAllTerritoryBoundaryPacket(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<packet::TerritoryBoundary>>> territories = 0) {
  AllTerritoryBoundaryPacketBuilder builder_(_fbb);
  builder_.add_territories(territories);
  return builder_.Finish();
}

inline flatbuffers::Offset<AllTerritoryBoundaryPacket> CreateAllTerritoryBoundaryPacketDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<packet::TerritoryBoundary>> *territories = nullptr) {
  auto territories__ = territories ? _fbb.CreateVector<flatbuffers::Offset<packet::TerritoryBoundary>>(*territories) : 0;
  return packet::CreateAllTerritoryBoundaryPacket(
      _fbb,
      territories__);
}

struct ActionPacket FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ActionPacketBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ENTITYIDS = 4,
    VT_ACTION = 6,
    VT_TARGET_TYPE = 8,
    VT_TARGET = 10,
    VT_PASSWORD = 12
  };
  const flatbuffers::Vector<flatbuffers::Offset<packet::EntityId>> *entityIds() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<packet::EntityId>> *>(VT_ENTITYIDS);
  }
  packet::ActionType action() const {
    return static_cast<packet::ActionType>(GetField<int16_t>(VT_ACTION, 0));
  }
  packet::Target target_type() const {
    return static_cast<packet::Target>(GetField<uint8_t>(VT_TARGET_TYPE, 0));
  }
  const void *target() const {
    return GetPointer<const void *>(VT_TARGET);
  }
  template<typename T> const T *target_as() const;
  const packet::EntityId *target_as_EntityId() const {
    return target_type() == packet::Target_EntityId ? static_cast<const packet::EntityId *>(target()) : nullptr;
  }
  const packet::Position *target_as_Position() const {
    return target_type() == packet::Target_Position ? static_cast<const packet::Position *>(target()) : nullptr;
  }
  const flatbuffers::String *password() const {
    return GetPointer<const flatbuffers::String *>(VT_PASSWORD);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ENTITYIDS) &&
           verifier.VerifyVector(entityIds()) &&
           verifier.VerifyVectorOfTables(entityIds()) &&
           VerifyField<int16_t>(verifier, VT_ACTION) &&
           VerifyField<uint8_t>(verifier, VT_TARGET_TYPE) &&
           VerifyOffset(verifier, VT_TARGET) &&
           VerifyTarget(verifier, target(), target_type()) &&
           VerifyOffset(verifier, VT_PASSWORD) &&
           verifier.VerifyString(password()) &&
           verifier.EndTable();
  }
};

template<> inline const packet::EntityId *ActionPacket::target_as<packet::EntityId>() const {
  return target_as_EntityId();
}

template<> inline const packet::Position *ActionPacket::target_as<packet::Position>() const {
  return target_as_Position();
}

struct ActionPacketBuilder {
  typedef ActionPacket Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_entityIds(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<packet::EntityId>>> entityIds) {
    fbb_.AddOffset(ActionPacket::VT_ENTITYIDS, entityIds);
  }
  void add_action(packet::ActionType action) {
    fbb_.AddElement<int16_t>(ActionPacket::VT_ACTION, static_cast<int16_t>(action), 0);
  }
  void add_target_type(packet::Target target_type) {
    fbb_.AddElement<uint8_t>(ActionPacket::VT_TARGET_TYPE, static_cast<uint8_t>(target_type), 0);
  }
  void add_target(flatbuffers::Offset<void> target) {
    fbb_.AddOffset(ActionPacket::VT_TARGET, target);
  }
  void add_password(flatbuffers::Offset<flatbuffers::String> password) {
    fbb_.AddOffset(ActionPacket::VT_PASSWORD, password);
  }
  explicit ActionPacketBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ActionPacketBuilder &operator=(const ActionPacketBuilder &);
  flatbuffers::Offset<ActionPacket> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ActionPacket>(end);
    return o;
  }
};

inline flatbuffers::Offset<ActionPacket> CreateActionPacket(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<packet::EntityId>>> entityIds = 0,
    packet::ActionType action = packet::ActionType_DEFAULT,
    packet::Target target_type = packet::Target_NONE,
    flatbuffers::Offset<void> target = 0,
    flatbuffers::Offset<flatbuffers::String> password = 0) {
  ActionPacketBuilder builder_(_fbb);
  builder_.add_password(password);
  builder_.add_target(target);
  builder_.add_entityIds(entityIds);
  builder_.add_action(action);
  builder_.add_target_type(target_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<ActionPacket> CreateActionPacketDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<packet::EntityId>> *entityIds = nullptr,
    packet::ActionType action = packet::ActionType_DEFAULT,
    packet::Target target_type = packet::Target_NONE,
    flatbuffers::Offset<void> target = 0,
    const char *password = nullptr) {
  auto entityIds__ = entityIds ? _fbb.CreateVector<flatbuffers::Offset<packet::EntityId>>(*entityIds) : 0;
  auto password__ = password ? _fbb.CreateString(password) : 0;
  return packet::CreateActionPacket(
      _fbb,
      entityIds__,
      action,
      target_type,
      target,
      password__);
}

struct OkPacket FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef OkPacketBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct OkPacketBuilder {
  typedef OkPacket Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit OkPacketBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  OkPacketBuilder &operator=(const OkPacketBuilder &);
  flatbuffers::Offset<OkPacket> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<OkPacket>(end);
    return o;
  }
};

inline flatbuffers::Offset<OkPacket> CreateOkPacket(
    flatbuffers::FlatBufferBuilder &_fbb) {
  OkPacketBuilder builder_(_fbb);
  return builder_.Finish();
}

struct ErrorPacket FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ErrorPacketBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CODE = 4,
    VT_MESSAGE = 6
  };
  int16_t code() const {
    return GetField<int16_t>(VT_CODE, 0);
  }
  const flatbuffers::String *message() const {
    return GetPointer<const flatbuffers::String *>(VT_MESSAGE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_CODE) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           verifier.VerifyString(message()) &&
           verifier.EndTable();
  }
};

struct ErrorPacketBuilder {
  typedef ErrorPacket Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_code(int16_t code) {
    fbb_.AddElement<int16_t>(ErrorPacket::VT_CODE, code, 0);
  }
  void add_message(flatbuffers::Offset<flatbuffers::String> message) {
    fbb_.AddOffset(ErrorPacket::VT_MESSAGE, message);
  }
  explicit ErrorPacketBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ErrorPacketBuilder &operator=(const ErrorPacketBuilder &);
  flatbuffers::Offset<ErrorPacket> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ErrorPacket>(end);
    return o;
  }
};

inline flatbuffers::Offset<ErrorPacket> CreateErrorPacket(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t code = 0,
    flatbuffers::Offset<flatbuffers::String> message = 0) {
  ErrorPacketBuilder builder_(_fbb);
  builder_.add_message(message);
  builder_.add_code(code);
  return builder_.Finish();
}

inline flatbuffers::Offset<ErrorPacket> CreateErrorPacketDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t code = 0,
    const char *message = nullptr) {
  auto message__ = message ? _fbb.CreateString(message) : 0;
  return packet::CreateErrorPacket(
      _fbb,
      code,
      message__);
}

struct LoginPacket FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LoginPacketBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LOGIN = 4,
    VT_PASSWORD = 6
  };
  const flatbuffers::String *login() const {
    return GetPointer<const flatbuffers::String *>(VT_LOGIN);
  }
  const flatbuffers::String *password() const {
    return GetPointer<const flatbuffers::String *>(VT_PASSWORD);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_LOGIN) &&
           verifier.VerifyString(login()) &&
           VerifyOffset(verifier, VT_PASSWORD) &&
           verifier.VerifyString(password()) &&
           verifier.EndTable();
  }
};

struct LoginPacketBuilder {
  typedef LoginPacket Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_login(flatbuffers::Offset<flatbuffers::String> login) {
    fbb_.AddOffset(LoginPacket::VT_LOGIN, login);
  }
  void add_password(flatbuffers::Offset<flatbuffers::String> password) {
    fbb_.AddOffset(LoginPacket::VT_PASSWORD, password);
  }
  explicit LoginPacketBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LoginPacketBuilder &operator=(const LoginPacketBuilder &);
  flatbuffers::Offset<LoginPacket> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LoginPacket>(end);
    return o;
  }
};

inline flatbuffers::Offset<LoginPacket> CreateLoginPacket(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> login = 0,
    flatbuffers::Offset<flatbuffers::String> password = 0) {
  LoginPacketBuilder builder_(_fbb);
  builder_.add_password(password);
  builder_.add_login(login);
  return builder_.Finish();
}

inline flatbuffers::Offset<LoginPacket> CreateLoginPacketDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *login = nullptr,
    const char *password = nullptr) {
  auto login__ = login ? _fbb.CreateString(login) : 0;
  auto password__ = password ? _fbb.CreateString(password) : 0;
  return packet::CreateLoginPacket(
      _fbb,
      login__,
      password__);
}

struct Position FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PositionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_X = 4,
    VT_Y = 6
  };
  int32_t x() const {
    return GetField<int32_t>(VT_X, 0);
  }
  int32_t y() const {
    return GetField<int32_t>(VT_Y, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_X) &&
           VerifyField<int32_t>(verifier, VT_Y) &&
           verifier.EndTable();
  }
};

struct PositionBuilder {
  typedef Position Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_x(int32_t x) {
    fbb_.AddElement<int32_t>(Position::VT_X, x, 0);
  }
  void add_y(int32_t y) {
    fbb_.AddElement<int32_t>(Position::VT_Y, y, 0);
  }
  explicit PositionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PositionBuilder &operator=(const PositionBuilder &);
  flatbuffers::Offset<Position> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Position>(end);
    return o;
  }
};

inline flatbuffers::Offset<Position> CreatePosition(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t x = 0,
    int32_t y = 0) {
  PositionBuilder builder_(_fbb);
  builder_.add_y(y);
  builder_.add_x(x);
  return builder_.Finish();
}

struct Packet FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PacketBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATA_TYPE = 4,
    VT_DATA = 6
  };
  packet::PacketType data_type() const {
    return static_cast<packet::PacketType>(GetField<uint8_t>(VT_DATA_TYPE, 0));
  }
  const void *data() const {
    return GetPointer<const void *>(VT_DATA);
  }
  template<typename T> const T *data_as() const;
  const packet::LoginPacket *data_as_LoginPacket() const {
    return data_type() == packet::PacketType_LoginPacket ? static_cast<const packet::LoginPacket *>(data()) : nullptr;
  }
  const packet::ActionPacket *data_as_ActionPacket() const {
    return data_type() == packet::PacketType_ActionPacket ? static_cast<const packet::ActionPacket *>(data()) : nullptr;
  }
  const packet::OkPacket *data_as_OkPacket() const {
    return data_type() == packet::PacketType_OkPacket ? static_cast<const packet::OkPacket *>(data()) : nullptr;
  }
  const packet::ErrorPacket *data_as_ErrorPacket() const {
    return data_type() == packet::PacketType_ErrorPacket ? static_cast<const packet::ErrorPacket *>(data()) : nullptr;
  }
  const packet::RegisterPacket *data_as_RegisterPacket() const {
    return data_type() == packet::PacketType_RegisterPacket ? static_cast<const packet::RegisterPacket *>(data()) : nullptr;
  }
  const packet::SelectFirstTerritory *data_as_SelectFirstTerritory() const {
    return data_type() == packet::PacketType_SelectFirstTerritory ? static_cast<const packet::SelectFirstTerritory *>(data()) : nullptr;
  }
  const packet::RequestAllTerritoryBoundaryPacket *data_as_RequestAllTerritoryBoundaryPacket() const {
    return data_type() == packet::PacketType_RequestAllTerritoryBoundaryPacket ? static_cast<const packet::RequestAllTerritoryBoundaryPacket *>(data()) : nullptr;
  }
  const packet::AllTerritoryBoundaryPacket *data_as_AllTerritoryBoundaryPacket() const {
    return data_type() == packet::PacketType_AllTerritoryBoundaryPacket ? static_cast<const packet::AllTerritoryBoundaryPacket *>(data()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_DATA_TYPE) &&
           VerifyOffset(verifier, VT_DATA) &&
           VerifyPacketType(verifier, data(), data_type()) &&
           verifier.EndTable();
  }
};

template<> inline const packet::LoginPacket *Packet::data_as<packet::LoginPacket>() const {
  return data_as_LoginPacket();
}

template<> inline const packet::ActionPacket *Packet::data_as<packet::ActionPacket>() const {
  return data_as_ActionPacket();
}

template<> inline const packet::OkPacket *Packet::data_as<packet::OkPacket>() const {
  return data_as_OkPacket();
}

template<> inline const packet::ErrorPacket *Packet::data_as<packet::ErrorPacket>() const {
  return data_as_ErrorPacket();
}

template<> inline const packet::RegisterPacket *Packet::data_as<packet::RegisterPacket>() const {
  return data_as_RegisterPacket();
}

template<> inline const packet::SelectFirstTerritory *Packet::data_as<packet::SelectFirstTerritory>() const {
  return data_as_SelectFirstTerritory();
}

template<> inline const packet::RequestAllTerritoryBoundaryPacket *Packet::data_as<packet::RequestAllTerritoryBoundaryPacket>() const {
  return data_as_RequestAllTerritoryBoundaryPacket();
}

template<> inline const packet::AllTerritoryBoundaryPacket *Packet::data_as<packet::AllTerritoryBoundaryPacket>() const {
  return data_as_AllTerritoryBoundaryPacket();
}

struct PacketBuilder {
  typedef Packet Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_data_type(packet::PacketType data_type) {
    fbb_.AddElement<uint8_t>(Packet::VT_DATA_TYPE, static_cast<uint8_t>(data_type), 0);
  }
  void add_data(flatbuffers::Offset<void> data) {
    fbb_.AddOffset(Packet::VT_DATA, data);
  }
  explicit PacketBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PacketBuilder &operator=(const PacketBuilder &);
  flatbuffers::Offset<Packet> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Packet>(end);
    return o;
  }
};

inline flatbuffers::Offset<Packet> CreatePacket(
    flatbuffers::FlatBufferBuilder &_fbb,
    packet::PacketType data_type = packet::PacketType_NONE,
    flatbuffers::Offset<void> data = 0) {
  PacketBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_data_type(data_type);
  return builder_.Finish();
}

inline bool VerifyTarget(flatbuffers::Verifier &verifier, const void *obj, Target type) {
  switch (type) {
    case Target_NONE: {
      return true;
    }
    case Target_EntityId: {
      auto ptr = reinterpret_cast<const packet::EntityId *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Target_Position: {
      auto ptr = reinterpret_cast<const packet::Position *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyTargetVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyTarget(
        verifier,  values->Get(i), types->GetEnum<Target>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyPacketType(flatbuffers::Verifier &verifier, const void *obj, PacketType type) {
  switch (type) {
    case PacketType_NONE: {
      return true;
    }
    case PacketType_LoginPacket: {
      auto ptr = reinterpret_cast<const packet::LoginPacket *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PacketType_ActionPacket: {
      auto ptr = reinterpret_cast<const packet::ActionPacket *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PacketType_OkPacket: {
      auto ptr = reinterpret_cast<const packet::OkPacket *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PacketType_ErrorPacket: {
      auto ptr = reinterpret_cast<const packet::ErrorPacket *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PacketType_RegisterPacket: {
      auto ptr = reinterpret_cast<const packet::RegisterPacket *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PacketType_SelectFirstTerritory: {
      auto ptr = reinterpret_cast<const packet::SelectFirstTerritory *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PacketType_RequestAllTerritoryBoundaryPacket: {
      auto ptr = reinterpret_cast<const packet::RequestAllTerritoryBoundaryPacket *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PacketType_AllTerritoryBoundaryPacket: {
      auto ptr = reinterpret_cast<const packet::AllTerritoryBoundaryPacket *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyPacketTypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyPacketType(
        verifier,  values->Get(i), types->GetEnum<PacketType>(i))) {
      return false;
    }
  }
  return true;
}

inline const packet::Packet *GetPacket(const void *buf) {
  return flatbuffers::GetRoot<packet::Packet>(buf);
}

inline const packet::Packet *GetSizePrefixedPacket(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<packet::Packet>(buf);
}

inline bool VerifyPacketBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<packet::Packet>(nullptr);
}

inline bool VerifySizePrefixedPacketBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<packet::Packet>(nullptr);
}

inline void FinishPacketBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<packet::Packet> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedPacketBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<packet::Packet> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace packet

#endif  // FLATBUFFERS_GENERATED_SCHEMA_PACKET_H_
